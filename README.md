<b>Blockchain</b> is a continuously growing list of records linked together by cryptography. Each such record contains the crypto hash of the block, a timestamp and the transaction itself (in short: the transaction is written to a block, where block is an alias to n-records). 

<b>Hash function</b> is a one-way function (can’t work reverse, if it injects A’s OP to produce B then it can’t inject B’s OP as it's input to produce A again). Hash function generates a sequence of strings of a fix length coined together in random order for a given message injected to it, which is true for that message and that message only. Hence, for any other message injected to that same hash function can not generate the same sequence of strings as it generated for the another message, making it a good application in blockchain tech (cryptography specifically). 

Hash function generates different outputs for different inputs, so that any modification to the input(s) can lead to complete change to the hash value generated by the hash function. Hence, nobody should be able to find two different input values that result in the same hash output.

Only way to reverse generate the message from hash value can be done by brute-forcing every combination of strings of that fix length. So for string length of 60, we have to check 2^60 combination of strings to produce the same hash value as before; which will take enormous computational power to perform.  

<b>Timestamp</b> is a secure way to keep track of creation and modification time for a record on the blockchain. It can not be changed once created. Timestamp are added by timestamping authority (TSA) in the following manner:
- Message to hash in requester
- requester calls for timestamp by injecting the hash it generated
- hash concatenated with the timestamp from TSA
- new hash generated for this
- the private key of TSA is signed onto this new hash generated
- signed hash and timestamp together are sent back to the requester of timestamp

According to the RFC spec of TSA: “A time-stamping service supports assertions of proof that a datum existed before a particular time.”

Blockchains are resistant to modification hence so to say once created it cannot be deleted or modified. It is an open, distributed ledger to store transactions between parties in verifiable and efficient way. Implemented via a p2p network adhering to validation protocol. Here’s how each block connects with each other:

Each box denotes a block and each arrow denotes the hash value of from-node being linked to to-node creating a chain of blocks connected together via these hash values (generated from hash functions) and appended as another value in its record which will later turn into its entire message and then used to generate another hash for the successive block and so on. In this figure, A is the starter node so it will not have any hash value in it’s ledger from the preceding block. In bitcoin, this block is called a genesis block on the Bitcoin network.
They are secure by design and highly fault tolerant. So, it becomes obvious to receive decentralized consensus (a keyword to denote agreement between masses) to use. It is public and distributed ledger where participating nodes can run transactions and create records and add them to the ledgers. These records can be seen by everyone on the p2p, irrespective if they participated in it or not.

Each block on the chain might contain more than one transaction record (generally it does). The block can be configured as to be added in a timely manner, ie., for a span of every 10 minutes, the transactions are copied onto a block (generated every 10 minute in this case) which in turn is added to the chain in the about configuration. Each transaction on the blocks are pre-validated (validation comes before record caching and block generation). This is called Block Time (more aptly: block generation interval).

<b>Q. So, someone hacked the blockchain somehow and modified someone’s transactions. Have it done something that really affects the entire blockchain integrity?</b>

No, It haven’t. Suppose there is blockchain network between some parties (p2p). A did some transaction publically. This transaction gets added to the existing blockchain once validated. Similarly, other transactions took place and a chain of blocks were added ahead of A’s latest transaction. Now, since A’s hash value is in the ledger of someone else’s block of transaction placed in front of it, changing A’s message (transaction record) will lead to re-generation of the hash value leading to a collusion with the hash value in the block in front of it (which is supposed to have the hash value if A), failing to confirm the integrity of the prior node (A) =>   
{  
hash_value_in_A != hash_value_in_successor_of_A  
}  
hence notifying the network about integrity hampering.

Implementation of the blockchain algorithm could be variable. In a blockchain using the proof-of-work system, the chain with the most cumulative proof-of-work is always considered the valid one by the network. So, if there are many blockchains to choose as the primary chain for the network, we choose the one with highest proof of work, which could be in terms of computation carried by each blockchain.

Node is a computer system on the p2p network of the blockchain. Every node is identifiable on the network by its public key, which works as an address of that node on the network (like destination IP address in routing algorithms). Every node carries a private key which is like paraphrase (only and only known to that node across the entire network) to the node. 

Suppose, there is a colony of houses aligned across the circumference of a circle. Each visible and connected by physical path to other (p2p) and marked with an unique number (public key => {could be random, could be in order, it doesn’t matter in this context}). However, each house is locked and the key (private key) to open the lock could be found with only and only the owner of that house.

Every node in a decentralized system has a copy of the blockchain. Data quality is maintained by massive database replication and computational trust. No centralized "official" copy exists and no user is "trusted" more than any other. Transactions are broadcast to the network using software. Having a connected network, reduces need and expense for external networking.  

By caching each transaction validation could be ran to check if the amount being processed is available in the ledger or not. If not, it is considered invalid; else it is valid.

Now, a transaction could be called to any entity of value being exchanged or transfered. And, any transaction could involve transfer of cryptocurrencies (crypto: currencies employing cryptography). There are many such currencies, popular ones including Bitcoin, Ethereum, Ripple. Dogecoin, etc. However, each currency is implemented differently from other, employing different methods of validation.

Some currencies came around as hard fork of others, like Bitcoin Cash and Ethereum Classic. Hard fork is a process where an existing blockchain splits into two separate chains (could be maintained independently being incompatible with each other) for a temporary of permanent span of time. 

Now, for a bitcoin network, a node can get its network address using its private keys. Creating a bitcoin address is nothing more than picking a random valid private key and computing the corresponding bitcoin address. This could done in split-second. The private keys are just character combinations in a randomly ordered fashion. However, one can not reverse engineer this ie., address to private key and even if one does so by brute forcing every combination of address, it is not feasible to say that the private key generated would be in use on the network and has funds as any node can have n-many private keys at its expense. 

For any transaction involving bitcoins, payer node must know its private key and accordingly sign the transaction. Every transaction contains its digital signature which can be generated using the public key of the transacting node on the network. The payer node generates a digital signature using its message and private key (aka passphrase). Now, on broadcasting this transaction is cached until it gets verified by other nodes on the network using the original message, digital signature and it’s public key (address of network). 

Bitcoin employs something Mining, for the record-keeping of the transactions using the computing power of every miner. Each miner is responsible to maintain the consistency of the blockchain. So, are they responsible to keep the blockchain updated and working at all times (hence not producing incompatibilities resulting to hard forks). Generally, transaction validated every 10 minute are written on a block and added to the chain. Each block contains a cryptographic (SHA-256: 32 bit) hash value for its preceding block hence forming a chain of blocks.

Now, to be accepted by rest of the network, the transaction must contain some proof of work to be supplied along with the hash value of the preceding block as told above. It is done by generating something called as cryptographic nouce value (an arbitrary value which can used only once) which is easy to verify but very time (and resource) consuming to generate. This nouce value is hashed along with the block content to meet the difficulty target (which changes every 14 days). So, to meet this target, one has to potentially check for a very large inventory of nouce value to hashed. The average number of nonces miners had to try before creating a new block (content + nouce value) is 200.5 quintillion. 

The proof-of-work system, alongside the chaining of blocks, makes modifications of the blockchain extremely hard, as an attacker must modify all subsequent blocks in order for the modifications of one block to be accepted.

Bitcoin was designed not to need a central authority and the bitcoin network is considered to be decentralized. However, researchers have pointed out a visible "trend towards centralization" by the means of miners joining large mining pools to minimise the variance of their income. According to researchers, other parts of the ecosystem are also "controlled by a small set of entities", notably online wallets and simplified payment verification clients.
A mining pool is the pooling of resources by miners, who share their processing power over a network, to split the reward equally, according to the amount of work they contributed to the probability of finding a block. Now, having these mining pools is kind of wrong because when combined they could produce immense power, enough to cross the barrier of 51% hashing power, which provides control to the entire blockchain.
